Due: 5/5/2017 @ 11:59pm


(0) CITATIONS, RESOURCES, ETC: Important!!

People: There are two other people in the class who did an Atari 2600 emulator. I discussed the part of the project relating to ROM loading and instruction execution with Neil and decided to go for C++ at his suggestion. I discussed approaches to graphics and modeling the TIA with Aditya V. and we decided to go for SDL.

Online resources:
       SDL tutorial:         http://stackoverflow.com/questions/4591076/c-sdl-on-macosx-without-xcode/12473310#12473310
       6502 instructions:    https://www.dwheeler.com/6502/oneelkruns/asm1step.html
       ATARI GRAPHICS:       http://www.randomterrain.com/atari-2600-memories-tutorial-andrew-davie-01.html (the test bins are from here too!! - amazing link)
       Color palette:        https://github.com/ppeccin/javatari/blob/master/javatari/src/org/javatari/atari/tia/video/NTSCPalette.java
             ^ this is another emulator that had an array of NTSC hex codes -> RGB color values, which I copy / pasted to save time.

(1) What did you end up doing?

I ended up writing an emulator for the Atari 2600. This involved parsing and loading game ROMs into memory, modeling the backend of a 6502 (or, more specifically, a 6507) processor, writing code that would handle ~130 separate instructions, and handling graphics and keyboard input.


(2) What was hard?

What wasn't hard? I did this project in C++, and I had never written a line of C++ in my life before it. I'd say the hardest part was finding good online documentation of tricky concepts like memory mirroring and indirect indexed addressing, and then implementing those in code without clear walkthroughs or guidelines - just intuition. The project involved a LOT of independent research and digging through old forums and Atari 2600 specifications to figure out corner cases for behavior or how the hardware, TIA chip, and PIA chip interacted with and even 'froze' the CPU. I also learned to use SDL to handle the graphics, input, and output.

(3) What did you learn?

The two most obvious skills that I will remember from this project for the next four years are C++ and graphics, as it was my first experience working with both. However, I think the biggest thing I am proud of after working with this project is just that - working on something that feels hard, entirely new, and completely uncomfortable. It involved a lot of small independent research into things I didn't know how to do - what are Atari ROMs formatted like? How do we load them into memory? Where do we start executing instructions? What do we need to execute instructions? Once that's done, how do we interact with the outside world? How do TVs and graphics chips work, how does the hardware sync up the CPU and TIA when they run at different speeds, how do we handle keyboard input and utilities the game can take advantage of (like timers)?

    I can confidently say I learned more from doing this one project than I did from some entire classes I'm taking this semester (looking at you, CC 303)

(4) What should your score be (out of 100)?

    I think I should get at least a 98! According to my google calendar and my commit history, I've spent about 35 hours working on pd, and I'm pretty happy with how it turned out. The project wasn't *entirely* complete, but the architecture part (emulating the processor) was 100% done. There are loose ends on graphics, but I think that's okay for how difficult the entire project is. It was hard, but fulfilling, and I learned a LOT.

    Current status: the 6502 processor should be fully functional! The games infinite loop when you run them (it's waiting for further input). I was only able to implement part of graphics, including displaying the background and playfield (not sprites yet), as well as handling keyboard input and timers. Since a lot of games do require those, *there are some sample .bins that will showcase the colorfulness of 1970s televisions. As mentioned above, these sample bins come from Andrew Davies, who has an online tutorial I followed about the graphics.


(5) Give me clear and concise instruction that would help me:

     (a) run your code and see that it worked

         There is a makefile, and running 'make clean && make' will generate an executable called atari.
         Running './atari BIN_NAME' will load the bin and begin executing it.

         Some games like pacman are included! They don't work fully, though. Try the test bins - t1.bin, t2.bin, t3.bin, etc.
              Those are from the andrew davies graphics tutorial and they showcase using basic instructions to display pretty things.

     (b) browse your code

         My code is split up into several different files.

            i) atari.cpp:           The main file. It calls minions to load the ROM, starts the graphics chip, and then executes instructions.

            ii) reada26.cpp:        Reads the file. It puts the ROM in an unsigned char array - straightforward stuff.

            iii) instructions.cpp:  Oh boy.

                               In instructions.h, there is a definition of an abstract class 'Instruction'. atari.cpp uses that interface to execute instructions.
                               This file defines roughly 120 subclasses of Instruction, each of which has a different execute(), different length, and different cycle count.
                               It also has a hashmap of opcodes to Instructions, so that the appropriate object can just be called. The 100 hashmap insertions are at the bottom.
                               At the top are useful methods for memory mirroring (turning a 6502 into a 6507), and a sanitized memory interface that mirrors.

            iv) tia.cpp:            The tia.cpp is also no joke.

                               It is initialized by atari.cpp, but ironically it controls the CPU. The TIA infinitely runs 3x something called a 'color_cycle', which is
                               meant to draw a single pixel - followed by exactly one cycle of the CPU. It also contains code that starts up SDL textures and the SDL window,
                               as well as the palette that reads in the desired current color and outputs it on the screen (see citation of another emulator in part 0).
